var tipuesearch = {"pages":[{"title":"About","text":"This is mykonakona.","tags":"pages","url":"https://mykonakona.github.io/about","loc":"https://mykonakona.github.io/about"},{"title":"[Virtual Machine]Hyper-V使用记录","text":"0. 起因 终于对自己一直使用的旧笔记本到了忍无可忍的地步，于是今年3月份在做了各种调研后购入了新机器（Lenove S740, i5 16G版本）。装机过程中我为了偷懒，打算直接用Win10自带的Hyper-V。自己打的如意算盘是可以省得装其他虚拟机软件，也能试一试好不好用。 首先，因为需要一个Win环境的虚拟机去跑一些国产流氓软件（比如长年在后台挂一个QQProtect进程的QQ），所以我考虑新建一个LTSC版本的Win10虚拟机。 这里有一点需要注意的是：Hyper-V给了第一代和第二代两种机器的选择。如果想传文件到第一代机器的虚拟机里，一种方法是通过设置局域网的共享文件夹，另一种好像是通过给虚拟机在硬盘上分一片虚拟硬盘的分区，两种方法都需要进行一些相对繁琐的操作和设置。所以除非需要用一些旧式驱动，一般用第二代机器就可以，因为二代机器支持增强对话，拷贝文件会比较方便且节省时间。 1. 第一个坑 一般情况下我们装系统到新建的虚拟机，都是通过虚拟的DVD光驱加载从网上下载得到的镜像文件（ISO、DMG等）进行安装。只要在建虚拟机时勾选上使用镜像安装的选项并选好镜像，Hyper-V就会自动把DVD设备的启动顺序放在第一位（其他虚拟机软件VMWare/VirtualBox一般也是这样）。但是在实际安装最新版本的Win10 LTSC时，Hyper-V不是直接进入安装界面，而是显示提示内容如下的页面： scsi dvd the boot loader failed 这说明通过DVD启动失败，没法进入镜像的安装界面。但本来这个DVD光驱就是一个虚拟设备，正常来说是不会有问题的。 google了半天才知道这里需要在虚拟机开机的时候用最快的速度按enter键才能进入系统安装界面（你也可以在开机时多按几次enter）。VMWare这一步是直接就进去了…… 2. 第二个坑 除了需要一个隔离环境运行一些流氓软件，我还有一个需求就是用安卓模拟器看青你或者看口袋48直播。因为现在爱奇艺网站必须注册才能看它提供的所谓的\"720P\"的视频源，非常恶心，为了看这个\"720P\"只能采用通过模拟器到APP里去看。如果打开了Hyper-V功能，诸如雷电、蓝叠、mumu这类模拟器会无法使用。因为现在市面几乎所有安卓模拟器本质上都是VitrualBox架构的虚拟机，而VitrualBox会和Hyper-V冲突。这些软件一般也会被在自己的使用说明里提到要在Win下关闭Hyper-V才能正常使用。 那打开Hyper-V功能后就没法在机器上开一个安卓模拟器了吗？也是有替代方案的。要想在Hyper-V下同时使用安卓模拟器可以参考 \"使用 Windows Hypervisor Platform 配置虚拟机加速\" 。这个方案是通过安装Android Studio( 国内需要改hosts ），使用IDE自带的模拟器去模拟。实测下来Android Studio的这个开发用模拟器是可以在打开Hyper-V的同时运行的，显示效果和流畅度也不错，但很非常吃配置。S740运行过程中CPU占用率一直是100%，这意味着不到一分钟机器就要开始产生大量发热和噪声。可能更高配置的机器可以使用这个兼容方案，但在我这里这个方案宣告失败。 3. 第三个坑（严格说不是Hyper-V的锅） 另一种方案是Hyper-V上装Android-x86的虚拟机。这一方案看上去很美好，但会碰到一些Android编译与开发环境的问题，难到了没有安卓经验的我。在安装镜像过程中，android-x86.org上的镜像基本上都试了个遍，有些镜像会出现键盘失效的情况，有些镜像能够正常安装，但安装完手机QQ或者微信并打开的时候，这些应用就一直弹停止提示，无法正常运行。google了下可能是由于大多数版本的Android-x86镜像基本不自带houdini的问题，导致微信、qq、口袋这些应用没法正常使用。 实在有点懒得继续再折腾。后来还试了试Win下的docker desktop，很流畅，但感觉用的人还是偏少，如果只是用来学习，应该还是基于Linux环境的讨论会比较多。 4. 小结 说了这么多，我最后把Hyper-V关了，去装了一个VMWare。","tags":"Virtual Machine","url":"https://mykonakona.github.io/2020/03/31/Hyper-V sucks/","loc":"https://mykonakona.github.io/2020/03/31/Hyper-V sucks/"},{"title":"[UserScript]使用用户脚本将Flash播放器替换为HTML5播放器","text":"做这个东西的动机其实是为了刷48的公演直播，本来一直在b站上看是没有问题的。但看这个月的n队N.E.W公演的那天，b站不知为何没有直播源了…… 也来不及搞清楚没有源这个事情是不是又是丝芭想搞闭环，总之当时除了模拟器登口袋，好像电脑上刷直播的方法就只剩在live.48.cn上看。 然后live48不出意料地还在用flash，我的火狐进去之后就是一块白板。虽然最后临时用CentBrowser刷了一下公演，但毕竟不是我的主力浏览器，刷完之后就莫名地感觉不爽…… 扒了扒greasefork，这方面脚本还是比较多的。找了一个用了dplayer的脚本 dilidili flash to html5 fix 开始抄。抄的过程中就感觉：如果只考虑满足最基本的需求，基本上还在使用Flash播放器的视频站都可以采用这个思路通过加载用户脚本做h5播放器的替换。 开始： 在head或者body加载dplayer的类库和hls的类库。 触发window.onload后，清空原播放器div下的子元素，append一个新div进去用于新播放器的使用。 写一个dplayer的构造函数，配好从原页面提取的视频url、视频类型为hls等配置项即可。 最后的结果可见 live48 html5 player 。","tags":"UserScript","url":"https://mykonakona.github.io/2019/04/29/use-a-user-script-to-replace-the-flash-player-with-an-HTML5-player/","loc":"https://mykonakona.github.io/2019/04/29/use-a-user-script-to-replace-the-flash-player-with-an-HTML5-player/"},{"title":"[Spider]jhao104/proxy_pool使用教程","text":"背景： 爬虫（spider）的目的大多是为了从特定网站上爬取我们所感兴趣的数据。但不是所有站点都欢迎这类数据爬取的行为，一种比较常见的反爬虫策略是屏蔽一段时间内多次访问站点的某个ip。为了突破这类反爬策略对单机爬取数据的限制，一种方法是维护一个代理池（proxy pool），通过使用不同的代理来规避网站的检测。jhao104/proxy_pool是Github上在国内使用比较多的一个代理池项目，这次主要记录一下从头开始建一个jhao104/proxy_pool的过程。 环境准备工作： 使用操作系统为：Linux Mint 19.1 \"Tessa\" - Xfce (64-bit) 安装git（Debian/Ubuntu） For the latest stable version for your release of Debian / Ubuntu $ apt-get install git For Ubuntu , this PPA provides the latest stable upstream Git version $ add-apt-repository ppa : git-core / ppa # apt update ; apt install git 安装pip（Debian/Ubuntu） Python 2 : $ sudo apt install python - pip Python 3 : $ sudo apt install python3 - venv python3 - pip 安装virtualenv（Python3版本） $ pip3 install virtualenv Creating virtual environments（Python3版本） Python3: $ python3 -m venv /path/to/new/virtual/environment 安装gcc（用于后续SSDB的编译） $ sudo apt-get instll gcc 安装SSDB （以下引自项目文档） $ wget --no-check-certificate https://github.com/ideawu/ssdb/archive/master.zip $ unzip master $ cd ssdb-master $ make optional, install ssdb in /usr/local/ssdb $ sudo make install 安装jhao104/proxy_pool （以下引自项目文档） 下载源码 : $ git clone https : // github . com / jhao104 / proxy_pool . git 建议这里先去激活新建的 python虚拟环境 ： $ cd / path / to / new / virtual / environment $ cd bin $ source activate 安装依赖 : $ pip install - r requirements . txt 启动: step1. 修改配置文件使jhao104/proxy_pool与SSDB使用的端口号一致。 step2. 启动SSDB （以下引自项目文档） start master : $ . / ssdb - server ssdb . conf or start as daemon : $ . / ssdb - server - d ssdb . conf step3. 启动jhao104/proxy_pool （以下引自项目文档） 如果你的依赖已经安全完成并且具备运行条件,可以直接在Run目录下运行main.py: $ python main.py 如果运行成功你应该看到有4个main.py进程。 你也可以分别运行他们: 依次到Api下启动ProxyApi.py，Schedule下启动ProxyRefreshSchedule.py和ProxyValidSchedule.py即可。 验证: 示例脚本get_status.py（通过api访问http://127.0.0.1:5010 查看当前代理池可用代理数） import requests print ( requests . get ( \"http://127.0.0.1:5010/get_status/\" ) . content ) 如在terminal中打印出当前的raw代理数和useful代理数，表示jhao104/proxy_pool已搭建成功:-)","tags":"Spider","url":"https://mykonakona.github.io/2019/03/30/tutorial-of-jhao104's-proxy_pool/","loc":"https://mykonakona.github.io/2019/03/30/tutorial-of-jhao104's-proxy_pool/"},{"title":"[Pelican]给博客加about与search页","text":"pelican里如果不做特别的设定的话，一般会有tags、categories、archives页，但不会有about页，有些主题会在页面顶部或其他位置放一个标为search的input元素，但直接输入搜索一般是无效的，需要配置对应的插件后才能生效。 1.添加about页： 基本上通用的做法是在content里新建一个pages目录，之后在pages目录下新建一个About.md，最简单的： title : About slug : about date : 2019 - 03 - 01 14 : 20 This is mykonakona . pelican会把pages目录下的.md都生成为静态页面。 然后在pelicanconf.py里加配置项,这里可以这样配置： PAGE_URL = '{slug}' PAGE_SAVE_AS = '{slug}/index.html' 2.添加search页： 这里涉及到一个主题和插件的选择，现在最简单的方式是用 tipue_search 插件。这个插件的README里主要推荐了两个主题，其中一个是elegant。 有关search页的最简要的配置基本如下: DIRECT_TEMPLATES = (('index', 'tags', 'categories','archives', 'search', '404')) PLUGIN_PATHS = ['plugins'] PLUGINS = ['tipue_search'] 为了配合 PlUGIN_PATHS 的路径，需要在 .travis.yml 的 script 里补上： script: - git clone --depth 1 https://github.com/mykonakona/pelican-plugins plugins 这里一般推荐从官方插件仓库fork过来一个，这样后续涉及到对插件做自定义时也会方便一些。","tags":"Pelican","url":"https://mykonakona.github.io/2019/03/04/add-about-and-search-page-for-your-pelican-weblog/","loc":"https://mykonakona.github.io/2019/03/04/add-about-and-search-page-for-your-pelican-weblog/"},{"title":"[Pelican]博客优化之添加disqus评论","text":"给博客加了disqus，但过程有点曲折。 不得不说pelican的教程确实有点少，如果不是这样一点点试可能真就卡在这个评论功能上了。很多博文里提完一句\"加配置 DISQUS-SITENAME = \"xxx\" \"就结束，其实根本没这么简单。 先说走了弯路的方法： 根据 windows下用Pelican+GitHub搭建静态博客 的方法： 注册完disqus账号后，在fork的elegant主题repo里建了一个 disqus.html ，然后disqus提供的通用html（即 \"how-to-add-disqus-comments\" 提到的第一步配置）拷进去。修改 articles.html ，在 article content 的div末尾加上一句 {% include 'disqus.html' %} 。 经实验，其实这样disqus就可以用了。但是你去看别人用了elegant的pelican站会发现，为什么他们的评论会隐藏？！ 正确的方法： 注册disqus账号。配置可以参考 \"how-to-add-disqus-comments\" （第一步和Trusted Domions那步都可以忽略）。 然后在 pelicanconf.py 里把disqus生成的一个 website shortname （在admin的setting-general页面）作为 DISQUS-SITENAME = \"xxx\" 的值填进去。 同时需要配置的还有: # 以https或http开头 ， io后面不带 / ， 详见pelican docs的 [ SITEURL配置说明 ][ 3 ] SITEURL = 'https://xxx.github.io' # 下面这项在publishconf . py里也要设成False RELATIVE_URLS = False 这时重新 make html 后就可以看到预期的效果了。","tags":"Pelican","url":"https://mykonakona.github.io/2019/02/28/how-to-add-disqus-comments-for-your-pelican-weblog/","loc":"https://mykonakona.github.io/2019/02/28/how-to-add-disqus-comments-for-your-pelican-weblog/"},{"title":"[Pelican]优化我的Pelican博客配置","text":"最近主要解决了配置上三个问题。 1.之前我的文章构建完都是堆在根目录下，数量多了就显得很杂乱，根据对应时间做检索也困难。 已解决 ：pelican其实有配置项可以让文章存到按指定规则生成的目录下。比如在pelicanconf.py加上下面的内容： # @see http://docs.getpelican.com/en/3.5.0/settings.html#url-settings ARTICLE_URL = '{date:%Y}/{date:%m}/{date:%d}/{slug}/' ARTICLE_SAVE_AS = '{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' 以这篇文章为例，在发布后你可以mykonakona.github.io的master分支下的 2019/02/27/fix-bugs-of-my-pelican-weblog 目录找到渲染后的页面（index.html)，它的url为: https://mykonakona.github.io/2019/02/27/fix-bugs-of-my-pelican-weblog/，和设置也可以对应起来。 2.构建时常看见Travis CI的job log有下面的WARNING信息： $ make publish pelican / home / travis / build /[ secure ]/[ secure ] . github . io / content - o / home / travis / build /[ secure ]/[ secure ] . github . io / output - s / home / travis / build /[ secure ]/[ secure ] . github . io / publishconf . py WARNING : % s usage in CATEGORY_FEED_ATOM is deprecated , use { slug } instead . WARNING : Feeds generated without SITEURL set properly may not be valid WARNING : Docutils has no localization for 'zh' . Using 'en' instead . Done : Processed 6 articles , 0 drafts , 0 pages , 0 hidden pages and 0 draft pages in 0.64 seconds . The command \"make publish\" exited with 0. 已解决 ：不去改其实也没事，但还是忍不住去改了。前两条光看内容似乎是CATEGORY_FEED_ATOM配置有问题，可能需要把FEED相关的配置都改一改。但打开pelicanconf.py一看有点怪： # Feed generation is usually not desired when developing FEED_ALL_ATOM = None CATEGORY_FEED_ATOM = None TRANSLATION_FEED_ATOM = None AUTHOR_FEED_ATOM = None AUTHOR_FEED_RSS = None 这时候回忆起来基本上都是默认，没做什么特别修改，十分困惑为什么有这个提示出来。 仔细查了查，发现其实publishconf.py是继承自pelicanconf.py（这点还是看到一个 issue 后才注意到的，捂脸），publishconf.py里关于FEED的选项也改成None就不会弹出提示了，但后面还是考虑要把订阅加上的。（这点也提醒大家在做这类静态博客的gernerater选型时还是要关注一下语言，如果熟悉js用hexo可能就好很多，可以节省很多时间。） 最后一条似乎是配置里的 Default_Lang 没有 zh ，就改回 en 了，懒。 3.自动构建完之后，master分支里除了一个index.html还会有一个index2.html，author目录下除了一个mykonakona.html外还会有一个mykonakona2.html。 已解决 ：其实这不算问题，因为pelican默认就是这样设置的（见 using-pagination-patterns ），比如设置的 DEFAULT_PAGINATION 设的值是5，然后到了第6篇文章的时候就会在index.html之外再生成一个index2.html。所以如果文章比较多又不希望仓库里有太多这种类型的html（这是什么奇怪需求？？？），可以把 DEFAULT_PAGINATION 的调小一点，或者参考 using-pagination-patterns 设置 PAGINATION_PATTERNS 。","tags":"Pelican","url":"https://mykonakona.github.io/2019/02/27/promote-conf-of-my-pelican-weblog/","loc":"https://mykonakona.github.io/2019/02/27/promote-conf-of-my-pelican-weblog/"},{"title":"[UserScript]我的第一个用户脚本","text":"用户脚本是什么？ 用户脚本是一段代码，它们能够优化您的网页浏览体验。安装之后，有些脚本能为网站添加新的功能，有些能使网站的界面更加易用，有些则能隐藏网站上烦人的部分内容。在 Greasy Fork 上的用户脚本都是由用户编写并向全世界发表的，您可以免费安装，轻松体验。 这是 GreasyFork 上给用户脚本（user scripts）的一个定义。但这个定义可能容易让人\"小看\"用户脚本的用途，事实上用户脚本的使用能够大大提升用户的浏览体验。 说来很羞耻，之所以会萌生写一个用户脚本的念头，是因为JAVLib逛太多，想更方便的从感兴趣的影片页面跳转到其他站点的下载页或视频页。虽然影片的评论页面会有一些下种链接，但这类种子一般都放在某个网盘里，下载时需要等待，实在不方便。别的自动获取磁链脚本装过一些，但似乎功能过于复杂了，有些只支持Chrome下使用（但前几天逛S1时无意看到 [网络]Chrome要禁油猴了？ ，Chrome凶多吉少？）。 于是开始找一些用户脚本编写的教程，打算自己写一个只做跳转不干其他事情的脚本。但在实际编码时我发现网上关于用户脚本编写与调试的内容都太简陋了。一些所谓的教程连如何调试用户脚本讲不清楚。有关调试基本写的都是什么\"调出控制台\"之类的正确的废话。就我自己而言，有些场景可能我会打日志，但多数时候我还是希望能够打断点调试的。所以开一个坑记录我自己在编写用户脚本时遇到的一些问题，希望能给没什么基础却同样想写一个实现自己需求的用户脚本的朋友一点点帮助。 Hints 1. 区别于普通的js文件，用户脚本文件的后缀名是.user.js。假如你想在放了脚本的仓库的readme里加一个点击安装的按钮，那只有.user.js才能触发脚本管理器（如Tampermonkey等）对脚本进行安装。 2. 只要@namespace不变，@name是可以随意修改的。但如果用户脚本在更新版本的同时修改了@namespace，用户将因为@namespace修改的缘故无法升级到该用户脚本的最新版本。只能重新安装最新版本的脚本。所以对于开发者来说@namespace的修改还需要慎重。这一点在Greasyfork关于 脚本元属性值 的站点帮助里也有提及: @namespace 与 @name 这两个属性被作为脚本的唯一标识符，用户脚本管理器根据它们来判断一个脚本是否已安装。Greasy Fork 也需要这些属性，若用户在更新脚本时改变了两者中的任意一项，将发出警告。 3. 一般来说@match就可以匹配你希望脚本生效的网址，但对JavLib这种有备用地址且经常会变的网站，可以用@include与正则来匹配，前提是备用地址有一定规律（比如\\w\\d\\d\\w.com的这种组合）。 4. 断点调试脚本目前我是通过在主力浏览器Firefox Quantum 65.0.1下安装附加组件 Omnibug 达成的。 5. 以 我的第一个用户脚本 为例，功能其实有点类似searchEngineJump，但由于这是一个adult脚本，所以是在 Sleazyfork 发布而不是Greasyfork发布，同时发布时需要勾选Adult Content选项。 6. 待后续补充……","tags":"UserScript","url":"https://mykonakona.github.io/2019/02/26/my-first-user-script/","loc":"https://mykonakona.github.io/2019/02/26/my-first-user-script/"},{"title":"[Powershell]编写批量端口telnet脚本完成网络打通验证","text":"前言 这篇16年左右写的，先占个坑，后面再调格式8。 背景 工作时经常需要测试生产机与终端机间的网络是否打通。由于生产机器数量较多，在登录每台终端机时手动telnet测试端口是否打通的方式会消耗较多时间。在这一背景下，产生了使用脚本自动完成该部分工作的需求。 在stackoverflow上也有人提出了类似的问题 Automate Telnet Port Testing On Windows 7 Using Batch Script 对于操作系统为Windows7的终端机，可以通过编写powershell脚本的方式完成这一任务。以下脚本在该问题答案的基础上，将逐个输入ip及端口进行测试的方法，修改为逐行读取预先准备的文本文档参数的方式。 脚本内容 #powershell ExecutionPolicy Bypass #powershell - File . / t2 . ps1 $ iplist = Get - Content C : \\ iplist . txt $ regH = \"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b\" $ regP = \"\\s(?<alp>\\d{1,5})\" $ remoteHost = \"\" $ Port = \"\" foreach ( $ i in $ iplist ) { if ( $ i - match $ regH ) { $ remoteHost = $ Matches [ 0 ] ; #write - host \"$remoteHost\" ; } if ( $ i - match $ regP ) { $ Port = $ Matches . alp ; #write - host \"$remotePort\" ; } try { $ socket = new - object System . Net . Sockets . TcpClient ( $ remoteHost , $ port ) } catch [ Exception ] { write - host $ remoteHost \":\" $ port \"Unconnected`n\" #write - host $ _ . Exception . GetType (). FullName #write - host $ _ . Exception . Message continue } write - host $ remoteHost \":\" $ port \"Connected`n\" } 端口及地址的列表文件示例 路径 C:\\iplist.txt 的文件内容大致如下： 127.0.0.1 8080 127.0.0.1 80 脚本的执行 执行该脚本前，将准备好的iplist.txt放到指定路径下（文中指定的路径为C:\\iplist.txt），再回到powershell下输入以下命令以获得执行权限。 powershell ExecutionPolicy Bypass 获得权限后，输入如下指令执行该脚本文件。 powershell -File ./t2.ps1 小结 该脚本主要包括三部分工作： 1. 读入准备好的iplist.txt文件 2. 使用正则逐行取出需要测试的ip及端口号 3. 将取出的ip和端口号填入System.Net.Sockets.TcpClient函数中并测试对应的ip及端口 其中不同于一般正则的地方的是 ?<alp> ，这部分较通俗的解释可见： PowerShell中正则表达式的运用","tags":"Windows","url":"https://mykonakona.github.io/2019/02/14/a-powershell-script-to-telnet-amount-of-remote-ports/","loc":"https://mykonakona.github.io/2019/02/14/a-powershell-script-to-telnet-amount-of-remote-ports/"},{"title":"1.3 Function to Prepend to Environment Variables","text":"本节的目的： How to use a list of paths Search for executables, libraries, and so on 常见的两个环境变量如下： $ echo $PATH /usr/bin:/bin $ echo $LD_LIBRARY_PATH /usr/lib:/lib 将 /opt/myapp/bin 添加到环境变量中： $ export PATH = /opt/myapp/bin: $PATH $ export LD_LIBRARY_PATH = /opt/myapp/lib ; $LD_LIBRARY_PATH bash: /opt/myapp/lib: No such file or directory 现在PATH和LD_LIBRARY_PATH变为： $ echo $PATH /opt/myapp/bin:/usr/bin:/bin $ echo $LD_LIBRARY_PATH /opt/myapp/lib 使用自定义的函数完成这一任务： $ prepend () { [ -d \" $2 \" ] && eval $1 = \\\" $2 ':' \\$ $1 \\\" && export $1 ; } $ prepend PATH /opt/myapp/bin $ prepend LD_LIBRARY_PATH /opt/myapp/lib prepend()的修改版，修正了环境变量为空时产生的bug： $ prepend () { [ -d \" $2 \" ] && eval $1 = \\\" $2 \\$\\{ $1 :+ ':' \\$ $1 \\}\\\" && export $1 ; }","tags":"Linux","url":"https://mykonakona.github.io/2018/10/03/function-to-prepend-to-environment-variables/","loc":"https://mykonakona.github.io/2018/10/03/function-to-prepend-to-environment-variables/"},{"title":"1.2 Playing with Variables and Environment Variables","text":"0. 基本概念 Variable type declaration - Not required in scripting languages >shell脚本在使用变量时不需要提前定义变量。Variable can be assigned directly. Assigning variables with quotes or without quotes for every variable >shell脚本在定义变量时可以用\"将变量括起。 >In bash for every variable is string. 1. 查看环境变量 如果gedit正在运行，可以使用 pgrep 命令查看其当前的进程ID，例如： $ pgrep gedit 11521 You can obtain the environment variable associated with the process by command $ cat /proc/11521/environ . 换行输出 $ cat /proc/11521/environ | tr '\\0' '\\n' 2. 赋值与输出 $ var = value 与 $ var=value 结果完全不同，前者会报错，后者将value赋给了var。 使用 $ echo $var $ echo ${ var } 都可以在terminal中输出结果。例如： 1 2 3 4 5 #!/bin/bash #Filename : variables.sh fruit = apple count = 5 echo \"We have $count ${ fruit } (s)\" 3. 环境变量 3.1. export HTTP_PROXY 是一个常见的envrionment variable。 $ HTTP_PROXY = 192 .168.1.23:3128 $ export HTTP_PROXY export命令用于set ENV variable 3.2. PATH $ echo $PATH 可查看环境变量PATH，如需要在PATH尾部添加新环境变量内容可对PATH赋新值： $ PATH = \" $PATH :/home/user/bin\" $ export PATH $ echo $PATH 3.3. 其他 Some of the well-known environment variable are home, pwd, user, uid, shell, and so on. 3.3.1. 用#取变量长度 $ length=${#var} 例如： $ var = 12345678901234567890 $ echo ${# var } 20 3.3.2. SHELL $ echo $SHELL /bin/bash uid value for the root user is 0 see: https://superuser.com/questions/626843/does-the-root-account-always-have-uid-gid-0 checking for superuser $ echo $0 whether the current script is running on root user or regular user uid for the root user is 0 3.3.3. set a custom PROMPT sring $ cat ~/.bashrc | grep PS1 ... $ PS1 = \"PROMPT>\" PROMT>PS1 = '${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' 这里： \\u expand user name \\h expand host name \\w expand current working directory","tags":"Linux","url":"https://mykonakona.github.io/2018/10/02/playing-with-vaiables-and-environment-variables/","loc":"https://mykonakona.github.io/2018/10/02/playing-with-vaiables-and-environment-variables/"},{"title":"1.1 Printing in the Terminal","text":"1. echo 1.1. 基本用法 echo是terminal中最常用的打印命令之一。 $ echo \"text\" $ echo 'text' $ echo text 都可以得到相同的输出。 1.2. 输出特殊符号 特殊符号，如exclamation mark（感叹号）的输出： $ echo \"cannot include exclamation - \" ! \" within double quotes\" 会得到一个 -su !\": event not found 因此需要通过\\进行转义，可修改为： $ echo \"cannot include exclamation - \" \\! \" within double quotes\" 下面三种方式都能够在terminal中得到相同的输出： echo Hello world ! echo 'Hello world !' echo \"Hello world \"\\!\"\" 1.3. ;的意义 在命令行中输入： $ echo hello ; hello 时，会将;后的hello识别为另一个命令。 1.4. -e $ echo \"1\\t2\\t3\" $ echo -e \"1\\t2\\t3\" 1.5. 使用echo输出带颜色的内容 常用输出字体的color code有：black 30 red 31 green 32 yellow 33 blue 34 white 37 echo -e \"\\e[1;31m This is red text \\e[0m\" \\e[1;31m 将echo输出的字体颜色设置成红色， \\e[0m 将其设置回原来的颜色。 常用输出底色的color code有：black 40 red 41 green 42 yellow 43 blue 44 white 47 echo -e \"\\e[1;42m Green Background\\e[0m\" 2. printf 另一个用于输出的命令是printf，下面的脚本中使用了printf的一些基本功能： 1 2 3 4 5 6 7 #!/bin/bash #Filename: printf.sh printf \"%-5s %-10s %-4s\\n\" No Name Mark printf \"%-5s %-10s %-4.2f\\n\" 1 Sarath 80 .3456 printf \"%-5s %-10s %-4.2f\\n\" 2 James 98 .9989 printf \"%-5s %-10s %-4.2f\\n\" 3 Jeff 77 .564 dash(即-）表示输出左对齐，如果不加-，表示输出右对齐。 dot 2(即.2）running off，精确到2位小数 slash n（即\\n）换行符","tags":"Linux","url":"https://mykonakona.github.io/2018/10/02/printing-in-the-terminal/","loc":"https://mykonakona.github.io/2018/10/02/printing-in-the-terminal/"},{"title":"[Linux]一个小需求背后的shell script细节","text":"0. 引子 公司目前在用的即时通讯软件里可用的表情太少，所以想导一份百度的泡泡表情进去。 看起来这玩意可以下载的地方还挺多的，但实际下载完发现下载站上的大小都偏大，于是就想是不是直接从百度贴吧里批量下载。 查看元素发现表情的url还是很有规律的，不用上正则了。在shell下写脚本就够用了，很快就写好了一个： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/sh if [ ! -d \"./bdpao/\" ] then mkdir bdpao else echo \"folder existed\" fi #我只想要黄脸表情，不需要其他的物件表情，所以把值设置为33 for (( i = 1 ; i< = 33 ; i++ )) do if [ \" $i \" -le 9 ] then dlurl = \"http://tb2.bdstatic.com/tb/editor/images/face/i_f0\" $i \".png?t=20140803\" wget -q \" $dlurl \" -O ./bdpao/0 $i .png else dlurl = \"http://tb2.bdstatic.com/tb/editor/images/face/i_f\" $i \".png?t=20140803\" wget -q \" $dlurl \" -O ./bdpao/ $i .png fi done zip -q -r bdpao.zip ./bdpao 然而实际运行时发现的问题，让我意识到自己对shell script的认识仍停留在一个一知半解的阶段。 1. 不同的循环风格 关于shell中常用的for循环的风格，根据 Linux shell 用for循环100次的方法 介绍的内容主要有C风格、Python风格（使用in）及使用seq。 1.1. C风格 我在编写脚本时，是先用C风格的for循环实现的，本来以为直接sh bdpao.sh就可以跑，但是实际运行时报了一个这样的错： bdpao.sh: 8: bdpao.sh: Syntax error: Bad for loop variable stackoverflow里有人也提了类似的问题 syntax-error-bad-for-loop-variable ，这里的解答说的比较清楚： + The for (( expr ; expr ; expr )) syntax is not available in sh. 即是说C风格在sh是不可用的。 解决方案：可以用 bash bdpao.sh ，或者改成while循环再用 sh bdpao.sh 运行。 1.2. Python风格 继续试了试Python风格，sh bdpao.sh后报了和之前不一样的错： bdpao.sh: 11: [: Illegal number: {1..33} 但换成bash可以运行，说明Python风格在sh下也不可用。 1.3. 使用seq 那么seq是不是也是一样呢？我把脚本修改成使用seq的形式，仍然报错了： bdpao.sh: 12: [: Illegal number: seq 1 33 不仅如此，bash bdpao.sh时，继续报错： ./bdpao.sh: line 12: [: seq 1 33: integer expression expected 为什么会这样呢，难道sh和bash都不支持seq，那为什么还有很多shell的教程里用seq做循环？ 原来这里我犯了一个最大的错误，但也是小白最大的陷阱，就是是'与`的区别，我在一知半解下把反引号当成单引号！但这两者意义完全不同。 据 (())与()还有${}差在哪？ 在bash shell中, \\$()与``(反引号)都是用来做命令替换(command substitution)的。所谓的命令替换是通过完成``或者$()里面的 命令，将其结果替换出来，再重组命令行。例如： $ echo the last sunday is $( date -d \"last sunday\" +%Y-%m-%d ) 将'改正为`后，用sh命令和bash命令都可以运行。 2. sh，./，还是bash？ 问题好像是解决了，但之前看《UNIX/Linux/OS X中的Shell编程（第4版）》里讲循环的章节，都是在shell下使用类似 for i in {1..33} 形式的循环写法。我在自己的linux试了一下也是可以，为什么把内容写进.sh文件里就会有这些问题？执行.sh脚本的时候，什么时候应该用sh，什么时候应该用bash？ what-is-the-purpose-of-the-sh-command 中有朋友解答了这一疑问：使用sh命令的目的是通过这一命令来指定运行环境。这种C风格、Python风格的for循环可以在shell下直接使用的原因是，大部分系统默认使用的shell是/bin/bash，这一点可以通过 查看当前使用的shell 来验证。 通过 echo $SHELL 可以发现系统默认的shell是/bin/bash，通过 echo $$ 查当前shell的进程号，结果如下： mint64@mint64-virtual-machine ~/Documents $ echo $$ 2265 mint64@mint64-virtual-machine ~/Documents $ ps -ef | grep '2265' mint64 2265 2258 0 Sep26 pts/6 00:00:01 bash mint64 44980 2265 0 15:56 pts/6 00:00:00 ps -ef mint64 44981 2265 0 15:56 pts/6 00:00:00 grep --color=auto 2265 当前系统使用的也确实是bash，这种通过查shell进程号确认当前使用shell的操作可以通过grep与awk的组合来做： ps | grep $$ | awk '{print $4}' 2.1. 三种情况 那么我们究竟应该如何选择shell脚本的执行命令呢？据 difference-between-and-sh-in-unix 的解答，使用sh file格式执行shell script时会新建一个shell进程，使用. file格式时是在当前的shell进程中执行shell脚本文件，而使用./file则是在当前目录下执行文件。 解答中还很贴心的举例说明了这三种情况，如果有一个名为test.sh的shell脚本文件，其内容为： 1 2 3 #!/bin/sh TEST = present 使用 sh test.sh 执行时，会运行一个新的sh，然后把脚本里的变量在这个sh中定义，最后退出。因此退出后如果用 echo $TEST 将没有结果输出，因为这个变量仅在 sh test.sh 时使用的sh里，在外部的shell不存在。 如果用 . test.sh 执行， echo $TEST 可以输出present的结果，因为这种方式是在当前的shell中执行shell脚本文件，而不是像 sh test.sh 一样新建一个sh。 如果用 ./test.sh 执行，这时#!/bin/sh被检测，等价于 /bin/sh ./test.sh 。 即是说，如果不需要指定运行环境的情况下，shell脚本文件的头部不加 shebang 的内容也是可以的。 3. 小结 现在网上不少教程只告诉你怎么做，并不会告诉你是为什么，所以网上搜到的海量内容不等同于自己的知识，只有甄别、消化乃至加工后的内容才能称得上是真正掌握。 最后，从需求入手永远是学习技术最快的一种方式。","tags":"Linux","url":"https://mykonakona.github.io/2018/09/28/details-of-shell-script-behind-a-simple-requirement/","loc":"https://mykonakona.github.io/2018/09/28/details-of-shell-script-behind-a-simple-requirement/"}]};